{"pages":[],"posts":[{"title":"树莓派+Opencv（一）图像处理","text":"通过安装在树莓派上的Opencv来进行图像处理 1、树莓派上安装配置opencv 我们从 opencv官网下载source文件，得到zip压缩包，这里推荐下载最新版本的Opencv，这里下载的是3.4.3版本，在安装前首先需要安装依赖包，在控制台输入： 123sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev\\然后下载OpenCV3.2.0和OpenCV_contrib-3.2.0，下载需要等待一段时间 之后输入： 123456unzip opencv-3.4.3.zip #解压文件cd opencv-3.4.3 #进入文件夹mkdir build #创建编译文件夹cd build #进入camke .. sudo make -j1 -j 是使用多少线程进行编译，在Ubuntu虚拟机上由于我设设置的性能较好，可以使用-j8进行编译，也就是8线程，而在树莓派上则是使用的单线程编译，速度会慢很多，但是保证不会死机，一开始使用-j4时到99%时就死机了。如果-j后不加数字，则默认不限制线程编译 编译完成后输入： 1sudo make install #执行安装 只要过一会就安装完成了。 2、编写Opencv代码 代码如下： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/opencv.hpp&gt; using namespace std; using namespace cv; void fun2(Mat); int main() { Mat img = imread(\"orgin.png\");//引入源图片文件 if (img.empty()) { return -1;//若没有图片文件，则为退出 } fun2(img);//将源图片文件传入 fun2() namedWindow(\"orgin\");//新建窗口 imshow(\"orgin\",img);//在orgin窗口下显示img namedWindow(\"new\"); waitKey(0); } void fun2(Mat img) { Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));//图像处理的主要函数，函数的参数第一个为选择的样式，这里我选择的是MORPH_RECT样式，大小设置为15 Mat dstimg; erode(img, dstimg, element);//将源文件进行处理，生成新的图像文件 imshow(\"new\", dstimg); imwrite(\"new.jpg\", dstimg);//将处理后的新图像文件保存为new.jpg } 新建一个文件夹，之后将图像文件和cpp文件放入在同一文件夹内。 3、运行代码 在树莓派上运行Opencv的代码有点繁琐，首先需要安装cmake gui，使用图形界面会比较方便些，这里在终端直接输入： 1sudo apt-get cmake-gui 进行安装。我们开始运行代码。在刚刚的文件夹里新建一个txt文件，这里推荐使用vim，当然也可以使用其他的文本编辑器，取名为CmakeLists.txt。CmakeLists的内容可以到Opencv的安装目录中找到Opencv官方的例子中直接复制过来就可以，不过需要改几个地方。 123456789101112131415161718192021222324252627282930# cmake needs this linecmake_minimum_required(VERSION 2.8)# Define project nameproject(opencv_example_project)# Find OpenCV, you may need to set OpenCV_DIR variable# to the absolute path to the directory containing OpenCVConfig.cmake file# via the command line or GUIfind_package(OpenCV REQUIRED)# If the package has been found, several variables will# be set, you can find the full list with descriptions# in the OpenCVConfig.cmake file.# Print some message showing some of themmessage(STATUS \"OpenCV library status:\")message(STATUS \" version: ${OpenCV_VERSION}\")message(STATUS \" libraries: ${OpenCV_LIBS}\")message(STATUS \" include path: ${OpenCV_INCLUDE_DIRS}\")if(CMAKE_VERSION VERSION_LESS \"2.8.11\") # Add OpenCV headers location to your include paths include_directories(${OpenCV_INCLUDE_DIRS})endif()# Declare the executable target built from your sourcesadd_executable(opencv_example opencvtest.cpp)# Link your application with OpenCV librariestarget_link_libraries(opencv_example ${OpenCV_LIBS}) 首先是为你的Opencv项目取名，当然如果不想改的话官方给的实例里已经给你取好了，其次就是将add_executable中的cpp文件改成自己写的代码的文件名，这样才可以知道编译的是哪个文件。 接下来就是使用cmake-gui编译了。打开终端，输入： 1cmake-gui 打开cmake-gui后看到界面，源代码处我们选择刚刚创建的文件夹，二进制文件一样也选择刚刚创建的文件夹，点击Add Entry，输入Opencv的安装位置，选择build文件夹，如图： 接着分别点击Configure和Generate，显示Configure Done和Generate Done就说明成功了。 回到终端，cd进入刚刚的文件夹，输入： 1ls #查看生成的可执行文件的名称 接着输入： 1./opencv_example 运行。运行结果如下：","link":"/2019/08/21/树莓派-Opencv（一）图像处理/"},{"title":"Spring学习日志(一)-HelloWorld及Bean配置","text":"Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。 1、Spring简介·Spring是一个开源框架。 ·Spring为简化企业级应用开发而生，使用Spring可以使简单的JavaBean实现以前只有EJB才能实现的功能。 ·Spring是一个IOC(DI)和AOP容器框架。 具体描述Spring： -轻量级：Spring是非入侵性的-基于Spring开发的应用中的对象可以不依赖于Spring的API -依赖注入（DI） -面向切面编程（AOP） -容器：Spring是一个容器，因为它包含并且管理应用对象的生命周期 -框架：Spring实现了使用简单的组件配置组合成一个复杂的应用，在Spring中可以使用XML和Java注解组合这些对象 -一站式：在IOC和AOP的基础上可以整合各种企业应用的开源框架和优秀的第三方类库 2、IOC容器IOC(Inversion of Control)：其思想是反转获取资源的方向，传统的资源查找方式，要求组件向容器发起请求查找资源，作为回应，容器适时的返回资源。而应用了IOC后，容器会主动地将资源推送给它所管理的组件，组件所要做的仅是选择一种合适的方式来接受资源。 配置Bean：-配置形式：主要分为两种一种是基于XML文件的方式；一种是基于注解的方式。这里主要使用XML文件方式。 -Bean的配置方式：通过全类名（反射）、通过工程方式、FactoryBean IOC容器BeanFactory&amp;ApplicationContext概述Spring提供了两种类型的IOC容器实现： -BeanFactory：IOC容器的基本实现，是Spring框架的基础设施，面向Spring本身 -ApplicationContext：提供了更多的高级特性，是BeanFactory的子接口，面向使用Spring框架的开发者，几乎所有应用场合都直接使用该实现方法。 ApplicationContext的主要实现类：-ClassPathXmlApplicationContext：从类路径下加载配置文件 -FileSystemXmlApplicationContext：从文件系统中加载配置文件 依赖注入方式-属性注入 -构造方式注入 -工厂方法注入（很少使用） 下面通过一个HelloWorld程序和一个简单的例子来展示属性注入和构造方式注入两种注入方式 3、开发环境在这里，可以直接使用封装好Spring Tool Suite的IDE，可以到Spring官网下载，也可以使用Eclipse中的 Spring Tool工具进行开发。 4、HelloWorldstep1：创建项目首先创建一个项目，命名为spring-1，并在src下创建一个包，名字按照Java的命名规范来命名。 step2：导入jar包点击Project-&gt;Java Build Path-&gt;Libraries-&gt;Add External JARs，这这里用到的JAR包可以到springframework的GitHub上下载。除此之外还需要一个common-logging.jar包。以上两个包的下载地址可以参考这篇文章。 step3：代码编写在src目录下，新建一个Spring Bean Configuration File，命名为applicationContext.xml。 在包中创建一个类命名为HelloWorld，同时创建一个Main方法类。其文件结构为： 编写HelloWorld在HelloWorld.java中的代码： 1234567891011package com.manuel.spring.beans;public class HelloWorld { private String userName; public void setUserName(String userName) { this.userName=userName; } public void hello() { System.out.println(\"Hello: \"+userName); }} 在applicationContext.xml中，创建一个Bean节点，只需输入： 1234&lt;bean id=\"helloWorld\" class=\"com.manuel.spring.beans.HelloWorld\"&gt; &lt;property name=\"userName\" value=\"Spring\"&gt;&lt;/property&gt;&lt;/bean&gt; 该方式为属性注入，即setter方法注入属性值或者依赖对象，为最常用的注入方法。 在Main.java中，创建Main方法，对对象进行实例化： 1234567891011121314151617181920212223242526public class Main { public static void main(String[] args) { // TODO Auto-generated method stub /* //创建Helloworld的一个对象 HelloWorld helloWorld = new HelloWorld(); //为name属性赋值 helloWorld.setUserName(\"\"); */ //1、创建Spring的IOC容器对象 //ApplicationContext 代表IOC容器 //ClassPathXmlApplicationContext:是Application接口的实现类，该实现类从类路径下来加载配置文件。 ApplicationContext ctxContext = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); //2、从IOC容器中获取bean的实例 //利用id定位到ioc容器中的bean HelloWorld helloWorld=(HelloWorld) ctxContext.getBean(\"helloWorld\"); //利用类型返回ioc容器中的bean，但要求ioc中必须只有该类型的bean //HelloWorld helloWorld=ctxContext.getBean(HelloWorld.class); //3、使用bean helloWorld.hello(); }} 运行后出现，Hello: Spring，说明成功编写了一个Spring HelloWorld程序。 接着编写一个简单的例子，实现构造器注入方式。 构造器注入方式简单例子在src中新建一个Car类，并创建实体和构造方法。代码如下 123456789101112131415161718192021222324252627282930package com.manuel.spring.beans;public class Car { private String brand; private String corp; private double price; private int maxSpeed; public Car(String brand, String corp, double price) { super(); this.brand = brand; this.corp = corp; this.price = price; } public Car(String brand, String corp, int maxSpeed) { super(); this.brand = brand; this.corp = corp; this.maxSpeed = maxSpeed; } @Override public String toString() { return \"Car [brand=\" + brand + \", corp=\" + corp + \", price=\" + price + \", maxSpeed=\" + maxSpeed + \"]\"; } } 在applicationContext.xml中，添加两个bean节点： 123456789101112131415&lt;!-- 通过构造方法来配置Bean的属性 --&gt;&lt;!--按索引匹配入参--&gt;&lt;bean id=\"car\" class=\"com.manuel.spring.beans.Car\"&gt; &lt;constructor-arg value=\"Benz\" index=\"0\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"Shanghai\" index=\"1\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"4000000\" type=\"double\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;&lt;!-- 使用构造器注入属性值可以指定参数的位置和参数的类型，以区分重载的构造器 --&gt;&lt;!--按类型匹配入参--&gt;&lt;bean id=\"car2\" class=\"com.manuel.spring.beans.Car\"&gt; &lt;constructor-arg value=\"BMW\" type=\"java.lang.String\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"Shanghai\" type=\"java.lang.String\"&gt;&lt;/constructor-arg&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"300\" type=\"int\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 之后在Main.java中对Car类型实例化，并输出变量： 12345Car car= (Car) ctxContext.getBean(\"car\");System.out.println(car); Car car2=(Car) ctxContext.getBean(\"car2\");System.out.println(car2); 最后得到结果： Car [brand=Benz, corp=Shanghai, price=4000000.0, maxSpeed=0]Car [brand=BMW, corp=Shanghai, price=0.0, maxSpeed=300] 通过不同的入参方式，可以区别不同bean节点的缺省参数，比如car中没有maxSpeed而car2中没有price，有maxSpeed，这样就可以通过不同的入参方式，来区别他们，以免car2的参数中原本是maxSpeed的参数变成了price的参数","link":"/2019/09/09/Spring学习日志-一-HelloWorld及Bean配置/"},{"title":"树莓派+Opencv（二）中文字库","text":"上一次实验完成了Opencv的安装以及图像的简单处理，现在在此基础上完成添加中文字的任务。 一、在字库文件中找到自己的名字 新建一个txt文本文件，写上名字学号，另存为，编码格式选择acsi。如何获得中文的的点阵位置呢，这里我们需要一个强大的工具，UltraEdit。使用UD打开之前创建的txt文件：打开点阵汉字查看程序，打开HZKf2424字库文件，在工具栏选择望远镜图标，也就是搜索图标，搜索E1D4：点击ok后出现的第一个字就是要搜索的字： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;cxcore.h&gt;#include &lt;highgui.h&gt;#include &lt;direct.h&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;const int CC_SIZE = 16;const int SAFE_WIDTH = 10;const int CC_NUMBER = 15;//姓名unsigned char name[7] = \"嵩\";unsigned int name_code[3][2];// 学号unsigned int id_code[12][2] = { { 0xa3, 0xb6 },{ 0xa3, 0xb3 },{ 0xa3, 0xb1 },{ 0xa3, 0xb6 },{ 0xa3, 0xb0 },{ 0xa3, 0xb7 },{ 0xa3, 0xb0 },{ 0xa3, 0xb4 },{ 0xa3, 0xb0 },{ 0xa3, 0xb3 },{ 0xa3, 0xb2 },{ 0xa3, 0xb5 } };unsigned char mat[16][2];FILE* HZK16;IplImage* img;void get_area_position_codes();void get_mat(int a_code, int p_code);void open_file();void draw_one_cc(int num);void release();int main(){ open_file(); get_area_position_codes(); int i, j; for (i = 0; i &lt; 3; ++i) { get_mat(name_code[i][0], name_code[i][1]); draw_one_cc(i); } for (j = 0; j &lt; 12; ++j) { get_mat(id_code[j][0] - 0xa0, id_code[j][1] - 0xa0); draw_one_cc(i + j); } cvShowImage(\"IMAGE\", img); cvWaitKey(0); release(); return 0;}void get_area_position_codes(){ for (int i = 0; i &lt; 3; ++i) for (int j = 0; j &lt; 2; ++j) name_code[i][j] = name[i * 2 + j] - 0xa0;}void get_mat(int a_code, int p_code){ long offset; offset = (94 * (a_code - 1) + (p_code - 1)) * 32L; // 读取数据存入数组 fseek(HZK16, offset, SEEK_SET); fread(mat, 32, 1, HZK16);}void open_file(){ char pbuf[100]; _getcwd(pbuf, 100); strcat(pbuf, \"\\\\HZKf1616.hz\"); // 读取图片 if ((img = cvLoadImage(\"orgin.png\")) == NULL)exit(1); // 打开字体文件 if ((HZK16 = fopen(pbuf, \"rb\")) == NULL)exit(1);}void draw_one_cc(int num){ int width, height; width = img-&gt;width; height = img-&gt;height; int start_x, start_y, size, current_start_x, current_start_y; size = CC_SIZE + SAFE_WIDTH; start_x = width - CC_NUMBER * size; start_y = height - CC_SIZE - SAFE_WIDTH; CvScalar cs; for (int i = 0; i &lt; 16; ++i) for (int j = 0; j &lt; 2; ++j) for (int k = 0; k &lt; 8; k++) if (mat[i][j] &amp; (0x80 &gt;&gt; k)) { cout &lt;&lt; mat[i][j] &lt;&lt; endl; current_start_x = j * 8 + k + start_x + size * num; current_start_y = start_y + i; cs = cvGet2D(img, current_start_y, current_start_x); cs.val[0] = 0;//B cs.val[1] = 69;//G cs.val[2] = 139;//R cvSet2D(img, current_start_y, current_start_x, cs); }}void release(){ cvReleaseImage(&amp;img); fclose(HZK16); img = NULL; HZK16 = NULL;} 该代码只能在windows上成功，在windows上中文的编码格式为utf-8，到了树莓派上，树莓派的中文编码是iso8859-1，所以程序会有错，程序无法运行。window上程序运行效果：树莓派上使用了另一代码，参考如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;opencv/cxcore.h&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;stdlib.h&gt;using namespace cv;using namespace std;class ShowName{public: ShowName(char *filename); ShowName(char *name, char* code); ~ShowName(); void openfile(); void get_name_code(); void get_mat(unsigned char qh, unsigned char wh); void draw_name(int num); void getasi(char incode[]); void draw_code(int num); void Runtodraw(); void file_Runtodraw();protected: FILE* CONTERNER; FILE* HZK24; FILE* ASI816; unsigned char mat[72]; unsigned char num_mat[16]; char name_code_box[30]; IplImage* img; const int MAPSIZE = 24; const int INTERSIZE = 5; unsigned char name_code[3][2];private: char *Name; char *code; char *Name_code; int sum_word; int current_num;};ShowName::~ShowName() { cvReleaseImage(&amp;img); fclose(HZK24); fclose(ASI816); if (CONTERNER!=NULL) { fclose(CONTERNER); } img = NULL; HZK24 = NULL; ASI816 = NULL; CONTERNER = NULL;}ShowName::ShowName(char *filename) { if ((CONTERNER = fopen(filename, \"rb\")) == NULL)exit(1); fseek(CONTERNER, 0, SEEK_SET); fread(name_code_box, 30, 1, CONTERNER); char *a = name_code_box; Name_code = a; sum_word = strlen(Name_code) - 2; current_num = 0; openfile();}ShowName::ShowName(char *name, char* code) { this-&gt;Name = name; this-&gt;code = code; this-&gt;current_num = 0; this-&gt;sum_word = strlen(Name) / 2 + strlen(this-&gt;code); openfile();}void ShowName::openfile() { char pbuf[100]; getcwd(pbuf, 100); strcat(pbuf, \"/HZKs2424.hz\"); char pbufASC[100]; getcwd(pbufASC, 100); strcat(pbufASC, \"/Asci0816.zf\"); if ((img=cvLoadImage(\"orgin.png\"))==NULL) { exit(1); } if ((HZK24=fopen(pbuf,\"rb\"))==NULL) { exit(1); } if ((ASI816=fopen(pbufASC,\"rb\"))==NULL) { exit(1); }}void ShowName::getasi(char incode[]){ unsigned char gh, wh; unsigned long offset; offset = incode[0] * 16L; fseek(ASI816, offset, SEEK_SET); fread(num_mat, 16, 1, ASI816);}void ShowName::get_mat(unsigned char qh, unsigned char wh) { long offset; offset = (94 * (qh - 1)) + (wh - 1) * 72L; fseek(HZK24, offset, SEEK_SET); fread(mat, 78, 1, HZK24);}void ShowName::draw_code(int num){ int width, height; width = img-&gt;width; height = img-&gt;height; int start_x, start_y, size, current_start_x, current_start_y; size = MAPSIZE; start_x = width - sum_word*size; start_y = height - 16 - INTERSIZE; CvScalar cs; for (int i = 0; i &lt; 16; i++) for (int k = 0; k &lt; 8; k++) if ((num_mat[i]&amp;(0x80&gt;&gt;k))!=NULL) { current_start_x=k+start_x+size*num; current_start_y=start_y+i; cs = cvGet2D(img, current_start_y, current_start_x); cs.val[0] = 0; cs.val[1] = 0; cs.val[2] = 0; cvSet2D(img, current_start_y, current_start_x, cs); }}void ShowName::draw_name(int num) { int width, height; width = img-&gt;width; height = img-&gt;height; int start_x, start_y, size, current_start_x, current_start_y; size = MAPSIZE;// +INTERSIZE; start_x = width - sum_word * size; start_y = height - MAPSIZE - INTERSIZE; CvScalar cs; for (int i = 0; i &lt; 24; ++i) for (int j = 0; j &lt; 3; ++j) for (int k = 0; k &lt; 8; k++) if (((mat[i * 3 + j] &gt;&gt; (7 - k)) &amp; 0x1) != NULL) { // »æµã current_start_x = start_x + i + size * num; current_start_y = start_y + j * 8 + k; cs = cvGet2D(img, current_start_y, current_start_x); cs.val[0] = 0; cs.val[1] = 0; cs.val[2] = 0; cvSet2D(img, current_start_y, current_start_x, cs); }}void ShowName::Runtodraw() { unsigned char mask = 0x80; char tmpcode[3] = { 0 }; while (*Name != NULL) { tmpcode[0] = *Name; tmpcode[1] = *(Name + 1); if (tmpcode[0] &amp; mask) { unsigned char qh, wh; qh = tmpcode[0] - 0xaf; wh = tmpcode[1] - 0xa0; get_mat(qh, wh); draw_name(current_num++); Name += 2; } } while (*code != NULL) { tmpcode[0] = *code; if (tmpcode[0]) { getasi(code); draw_code(current_num++); code++; } } cvShowImage(\"bt\", img); cvWaitKey();}void ShowName::file_Runtodraw() { unsigned char mask = 0x80; char tmpcode[3] = { 0 }; int x = 0; while (*Name_code != NULL) { tmpcode[0] = *Name_code; tmpcode[1] = *(Name_code + 1); if (tmpcode[0] &amp; mask) { unsigned char qh, wh; qh = tmpcode[0] - 0xaf; wh = tmpcode[1] - 0xa0; get_mat(qh, wh); draw_name(current_num++); Name_code += 2; } else if (tmpcode[0]) { getasi(Name_code); draw_code(current_num++); Name_code++; } } cvShowImage(\"bt\", img); cvWaitKey();}int main(){ char *filename = (char*)\"zh.txt\"; ShowName *newname = new ShowName(filename); newname-&gt;file_Runtodraw(); delete newname; return 0;} 这里需要注意几个地方，在Linux无法使用direct.h头文件，_getcwd在Linux下是不需要前面的”_”的，还需要引入unistd.h头文件。 运行方式可以参考我之前的文章：树莓派+Opencv（一）图像处理 程序运行结果：","link":"/2019/08/21/树莓派-Opencv（二）中文字库/"},{"title":"基于树莓派平台宿舍人脸智能门锁系统","text":"1、设计目的本报告从树莓派平台入手，分析基于树莓派开发的人脸识别门锁系统的必要性和可行性。 2、实验详细步骤2.1安装Python3树莓派自带的Python版本是2.7，本次需要用到Python3。在Linux上安装Python3很简单，只需要执行： 12sudo apt-get updata sudo apt-get install python3 2.2安装Opencv安装Python3的OpenCV就比较麻烦，需要对源码进行编译操作。首次安装需要执行： 12345678sudo apt-get install build-essential git cmake pkg-config -ysudo apt-get install libjpeg8-dev -ysudo apt-get install libtiff5-dev -ysudo apt-get install libjasper-dev -ysudo apt-get install libpng12-dev -ysudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev -ysudo apt-get install libgtk2.0-dev -ysudo apt-get install libatlas-base-dev gfortran -y 之后执行： 123cd /home/pi/Downloadswget https://github.com/Itseez/opencv/archive/3.4.0.zipwget https://github.com/Itseez/opencv_contrib/archive/3.4.0.zip 设置编译参数： 123cd /home/pi/Downloads/opencv-3.4.0mkdir buildcd build 设置cmake参数： 1cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D OPENCV_EXTRA_MODULES_PATH=/home/pi/Downloads/opencv_contrib-3.4.0/modules -D BUILD_EXAMPLES=ON -D WITH_LIBV4L=ON PYTHON3_EXECUTABLE=/usr/bin/python3.5 PYTHON_INCLUDE_DIR=/usr/include/python3.5 PYTHON_LIBRARY=/usr/lib/arm-linux-gnueabihf/libpython3.5m.so PYTHON3_NUMPY_INCLUDE_DIRS=/home/pi/.local/lib/python3.5/site-packages/numpy/core/include .. 最后执行编译： 12cd /home/pi/Downloads/opencv-3.4.0/buildmake 执行完成后，运行安装： 1sudo make install 2.3安装OpenCV-contribPython3的OpenCV-contrib库的安装就比较容易了，只需要使用pip进行安装： 1sudo pip3 install opencv-contrib-python 2.4收集人脸数据首先需要进入到FacialRecognitionProject文件夹中，在该文件夹下创建一个人脸数据存放的文件夹。运行： 1mkdir dataset 之后运行01_face_dataset.py。代码如下： 12345678import cv2import oscam = cv2.VideoCapture(0)cam.set(3, 640) # set video widthcam.set(4, 480) # set video heightface_detector = cv2.CascadeClassifier('haarcascade_frontalface_default.xml') haarcascade_frontalface_default.xml为人脸分类器每个人的录入都需要一个id作为标志 123face_id = input('\\n enter user id end press &lt;return&gt; ==&gt; ')print(\"\\n [INFO] Initializing face capture. Look the camera and wait ...\") 运行人脸采集 123456789101112131415161718192021222324252627count = 0while(True): ret, img = cam.read() img = cv2.flip(img, -1) # flip video image vertically gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_detector.detectMultiScale(gray, 1.3, 5) for (x, y, w, h) in faces: cv2.rectangle(img, (x, y), (x+w, y+h), (255, 0, 0), 2) count += 1 # Save the captured image into the datasets folder cv2.imwrite(\"dataset/User.\" + str(face_id) + '.' + str(count) + \".jpg\", gray[y:y+h, x:x+w]) cv2.imshow('image', img) k = cv2.waitKey(100) &amp; 0xff # Press 'ESC' for exiting video if k == 27: break elif count &gt;= 30: # Take 30 face sample and stop video breakprint(\"\\n [INFO] Exiting Program and cleanup stuff\")cam.release()cv2.destroyAllWindows() 运行后，输入id号，然后对着摄像头，稍等一会，等待摄像头采集30张人脸数据后，程序会自动结束。程序会采集人脸，以及眼睛等特征数据。 2.5训练在这里，我们需要创建一个用于存储训练数据的文件夹。 1mkdir trainer 接着运行02_face_training.py代码如下： 1234567import cv2import numpy as npfrom PIL import Imageimport os# Path for face image databasepath = 'dataset' 创建人脸识别器然后倒入人脸分类器 12recognizer = cv2.face.LBPHFaceRecognizer_create()detector = cv2.CascadeClassifier(\"haarcascade_frontalface_default.xml\"); 获取照片及其标签方法 12345678910111213141516171819def getImagesAndLabels(path): imagePaths = [os.path.join(path,f) for f in os.listdir(path)] faceSamples=[] ids = [] for imagePath in imagePaths: PIL_img = Image.open(imagePath).convert('L') # convert it to grayscale img_numpy = np.array(PIL_img,'uint8') id = int(os.path.split(imagePath)[-1].split(\".\")[1]) faces = detector.detectMultiScale(img_numpy) for (x,y,w,h) in faces: faceSamples.append(img_numpy[y:y+h,x:x+w]) ids.append(id) return faceSamples,ids 使用人脸识别器来对id1的数据进行训练 123print (\"\\n [INFO] Training faces. It will take a few seconds. Wait ...\")faces,ids = getImagesAndLabels(path)recognizer.train(faces, np.array(ids)) 将模型保存为yml文件 1234recognizer.write('trainer/trainer.yml') # recognizer.save() worked on Mac, but not on Pi# Print the numer of faces trained and end programprint(\"\\n [INFO] {0} faces trained. Exiting Program\".format(len(np.unique(ids)))) 稍等片刻，训练就完成了，由于是小样本，只有30张，所以训练的很快。训练好的模型保存为yml文件，存储在刚刚创建的trainer目录中。 2.6人脸识别器训练完成后，就可以开始进行识别了。运行03_face_recognition.py。代码如下： 123import cv2import numpy as npimport os 创建人脸识别器并导入训练好的模型和人脸分类器 1234recognizer = cv2.face.LBPHFaceRecognizer_create()#创建人脸识别器recognizer.read('trainer/trainer.yml')#导入刚刚训练好的模型cascadePath = \"haarcascade_frontalface_default.xml\"faceCascade = cv2.CascadeClassifier(cascadePath);#导入人脸分类器 设置界面 12345678910111213141516font = cv2.FONT_HERSHEY_SIMPLEX#iniciate id counterid = 0# names related to ids: example ==&gt; Marcelo: id=1, etcnames = ['None', 'wcs'] # Initialize and start realtime video capturecam = cv2.VideoCapture(0)cam.set(3, 640) # set video widhtcam.set(4, 480) # set video height# Define min window size to be recognized as a faceminW = 0.1*cam.get(3)minH = 0.1*cam.get(4) 创建循环，运行人脸识别 1234567891011121314151617181920212223242526272829303132333435363738394041while True: ret, img =cam.read() img = cv2.flip(img, -1) # Flip vertically gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)#将图片转化为灰度图 faces = faceCascade.detectMultiScale( gray, scaleFactor = 1.2, minNeighbors = 5, minSize = (int(minW), int(minH)), ) for(x,y,w,h) in faces: cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2) id, confidence = recognizer.predict(gray[y:y+h,x:x+w])#获取预测值 # Check if confidence is less them 100 ==&gt; \"0\" is perfect match if (confidence &lt; 100): id = names[id] confidence = \" {0}%\".format(round(100 - confidence)) else: id = \"unknown\" confidence = \" {0}%\".format(round(100 - confidence)) cv2.putText(img, str(id), (x+5,y-5), font, 1, (255,255,255), 2) cv2.putText(img, str(confidence), (x+5,y+h-5), font, 1, (255,255,0), 1) cv2.imshow('camera',img) k = cv2.waitKey(10) &amp; 0xff # Press 'ESC' for exiting video if k == 27: break# Do a bit of cleanupprint(\"\\n [INFO] Exiting Program and cleanup stuff\")cam.release()cv2.destroyAllWindows() 运行完成后就可以在屏幕上看到结果了。 3、系统性能测试和分析程序运行起来还是比较顺利的，在人像采集的时候，需要看着摄像头，摄像头只有在检测到人脸和眼睛等特征的情况下才会截取。由于是小样本，设置了只有30张样本照片。所以识别率不是很高。在识别的时候识别率最高只有50%+，有时候甚至拿其他人的照片也会被识别出来，不过识别率只有1%-10%。不过在智能门锁的应用上，可以将其设置为识别率超过50%才可以开锁解决误判。","link":"/2019/08/21/基于树莓派平台宿舍人脸智能门锁系统/"}],"tags":[{"name":"树莓派","slug":"树莓派","link":"/tags/树莓派/"},{"name":"Opencv","slug":"Opencv","link":"/tags/Opencv/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"Java","slug":"Java","link":"/tags/Java/"}],"categories":[{"name":"树莓派","slug":"树莓派","link":"/categories/树莓派/"},{"name":"Spring","slug":"Java","link":"/categories/Java/"}]}
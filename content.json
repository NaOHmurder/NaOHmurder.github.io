{"pages":[],"posts":[{"title":"基于树莓派平台宿舍人脸智能门锁系统","text":"1、设计目的本报告从树莓派平台入手，分析基于树莓派开发的人脸识别门锁系统的必要性和可行性。 2、实验详细步骤2.1安装Python3树莓派自带的Python版本是2.7，本次需要用到Python3。在Linux上安装Python3很简单，只需要执行： 12sudo apt-get updata sudo apt-get install python3 2.2安装Opencv安装Python3的OpenCV就比较麻烦，需要对源码进行编译操作。首次安装需要执行： 12345678sudo apt-get install build-essential git cmake pkg-config -ysudo apt-get install libjpeg8-dev -ysudo apt-get install libtiff5-dev -ysudo apt-get install libjasper-dev -ysudo apt-get install libpng12-dev -ysudo apt-get install libavcodec-dev libavformat-dev libswscale-dev libv4l-dev -ysudo apt-get install libgtk2.0-dev -ysudo apt-get install libatlas-base-dev gfortran -y 之后执行： 123cd /home/pi/Downloadswget https://github.com/Itseez/opencv/archive/3.4.0.zipwget https://github.com/Itseez/opencv_contrib/archive/3.4.0.zip 设置编译参数： 123cd /home/pi/Downloads/opencv-3.4.0mkdir buildcd build 设置cmake参数： 1cmake -D CMAKE_BUILD_TYPE=RELEASE -D CMAKE_INSTALL_PREFIX=/usr/local -D INSTALL_C_EXAMPLES=ON -D INSTALL_PYTHON_EXAMPLES=ON -D OPENCV_EXTRA_MODULES_PATH=/home/pi/Downloads/opencv_contrib-3.4.0/modules -D BUILD_EXAMPLES=ON -D WITH_LIBV4L=ON PYTHON3_EXECUTABLE=/usr/bin/python3.5 PYTHON_INCLUDE_DIR=/usr/include/python3.5 PYTHON_LIBRARY=/usr/lib/arm-linux-gnueabihf/libpython3.5m.so PYTHON3_NUMPY_INCLUDE_DIRS=/home/pi/.local/lib/python3.5/site-packages/numpy/core/include .. 最后执行编译： 12cd /home/pi/Downloads/opencv-3.4.0/buildmake 执行完成后，运行安装： 1sudo make install 2.3安装OpenCV-contribPython3的OpenCV-contrib库的安装就比较容易了，只需要使用pip进行安装： 1sudo pip3 install opencv-contrib-python 2.4收集人脸数据首先需要进入到FacialRecognitionProject文件夹中，在该文件夹下创建一个人脸数据存放的文件夹。运行： 1mkdir dataset 之后运行01_face_dataset.py。代码如下： 12345678import cv2import oscam = cv2.VideoCapture(0)cam.set(3, 640) # set video widthcam.set(4, 480) # set video heightface_detector = cv2.CascadeClassifier('haarcascade_frontalface_default.xml') haarcascade_frontalface_default.xml为人脸分类器每个人的录入都需要一个id作为标志 123face_id = input('\\n enter user id end press &lt;return&gt; ==&gt; ')print(\"\\n [INFO] Initializing face capture. Look the camera and wait ...\") 运行人脸采集 123456789101112131415161718192021222324252627count = 0while(True): ret, img = cam.read() img = cv2.flip(img, -1) # flip video image vertically gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) faces = face_detector.detectMultiScale(gray, 1.3, 5) for (x, y, w, h) in faces: cv2.rectangle(img, (x, y), (x+w, y+h), (255, 0, 0), 2) count += 1 # Save the captured image into the datasets folder cv2.imwrite(\"dataset/User.\" + str(face_id) + '.' + str(count) + \".jpg\", gray[y:y+h, x:x+w]) cv2.imshow('image', img) k = cv2.waitKey(100) &amp; 0xff # Press 'ESC' for exiting video if k == 27: break elif count &gt;= 30: # Take 30 face sample and stop video breakprint(\"\\n [INFO] Exiting Program and cleanup stuff\")cam.release()cv2.destroyAllWindows() 运行后，输入id号，然后对着摄像头，稍等一会，等待摄像头采集30张人脸数据后，程序会自动结束。程序会采集人脸，以及眼睛等特征数据。 2.5训练在这里，我们需要创建一个用于存储训练数据的文件夹。 1mkdir trainer 接着运行02_face_training.py代码如下： 1234567import cv2import numpy as npfrom PIL import Imageimport os# Path for face image databasepath = 'dataset' 创建人脸识别器然后倒入人脸分类器 12recognizer = cv2.face.LBPHFaceRecognizer_create()detector = cv2.CascadeClassifier(\"haarcascade_frontalface_default.xml\"); 获取照片及其标签方法 12345678910111213141516171819def getImagesAndLabels(path): imagePaths = [os.path.join(path,f) for f in os.listdir(path)] faceSamples=[] ids = [] for imagePath in imagePaths: PIL_img = Image.open(imagePath).convert('L') # convert it to grayscale img_numpy = np.array(PIL_img,'uint8') id = int(os.path.split(imagePath)[-1].split(\".\")[1]) faces = detector.detectMultiScale(img_numpy) for (x,y,w,h) in faces: faceSamples.append(img_numpy[y:y+h,x:x+w]) ids.append(id) return faceSamples,ids 使用人脸识别器来对id1的数据进行训练 123print (\"\\n [INFO] Training faces. It will take a few seconds. Wait ...\")faces,ids = getImagesAndLabels(path)recognizer.train(faces, np.array(ids)) 将模型保存为yml文件 1234recognizer.write('trainer/trainer.yml') # recognizer.save() worked on Mac, but not on Pi# Print the numer of faces trained and end programprint(\"\\n [INFO] {0} faces trained. Exiting Program\".format(len(np.unique(ids)))) 稍等片刻，训练就完成了，由于是小样本，只有30张，所以训练的很快。训练好的模型保存为yml文件，存储在刚刚创建的trainer目录中。 2.6人脸识别器训练完成后，就可以开始进行识别了。运行03_face_recognition.py。代码如下： 123import cv2import numpy as npimport os 创建人脸识别器并导入训练好的模型和人脸分类器 1234recognizer = cv2.face.LBPHFaceRecognizer_create()#创建人脸识别器recognizer.read('trainer/trainer.yml')#导入刚刚训练好的模型cascadePath = \"haarcascade_frontalface_default.xml\"faceCascade = cv2.CascadeClassifier(cascadePath);#导入人脸分类器 设置界面 12345678910111213141516font = cv2.FONT_HERSHEY_SIMPLEX#iniciate id counterid = 0# names related to ids: example ==&gt; Marcelo: id=1, etcnames = ['None', 'wcs'] # Initialize and start realtime video capturecam = cv2.VideoCapture(0)cam.set(3, 640) # set video widhtcam.set(4, 480) # set video height# Define min window size to be recognized as a faceminW = 0.1*cam.get(3)minH = 0.1*cam.get(4) 创建循环，运行人脸识别 1234567891011121314151617181920212223242526272829303132333435363738394041while True: ret, img =cam.read() img = cv2.flip(img, -1) # Flip vertically gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)#将图片转化为灰度图 faces = faceCascade.detectMultiScale( gray, scaleFactor = 1.2, minNeighbors = 5, minSize = (int(minW), int(minH)), ) for(x,y,w,h) in faces: cv2.rectangle(img, (x,y), (x+w,y+h), (0,255,0), 2) id, confidence = recognizer.predict(gray[y:y+h,x:x+w])#获取预测值 # Check if confidence is less them 100 ==&gt; \"0\" is perfect match if (confidence &lt; 100): id = names[id] confidence = \" {0}%\".format(round(100 - confidence)) else: id = \"unknown\" confidence = \" {0}%\".format(round(100 - confidence)) cv2.putText(img, str(id), (x+5,y-5), font, 1, (255,255,255), 2) cv2.putText(img, str(confidence), (x+5,y+h-5), font, 1, (255,255,0), 1) cv2.imshow('camera',img) k = cv2.waitKey(10) &amp; 0xff # Press 'ESC' for exiting video if k == 27: break# Do a bit of cleanupprint(\"\\n [INFO] Exiting Program and cleanup stuff\")cam.release()cv2.destroyAllWindows() 运行完成后就可以在屏幕上看到结果了。 3、系统性能测试和分析程序运行起来还是比较顺利的，在人像采集的时候，需要看着摄像头，摄像头只有在检测到人脸和眼睛等特征的情况下才会截取。由于是小样本，设置了只有30张样本照片。所以识别率不是很高。在识别的时候识别率最高只有50%+，有时候甚至拿其他人的照片也会被识别出来，不过识别率只有1%-10%。不过在智能门锁的应用上，可以将其设置为识别率超过50%才可以开锁解决误判。","link":"/2019/08/21/基于树莓派平台宿舍人脸智能门锁系统/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/08/19/hello-world/"},{"title":"树莓派+Opencv（一）图像处理","text":"1、树莓派上安装配置opencv 我们从 opencv官网下载source文件，得到zip压缩包，这里推荐下载最新版本的Opencv，这里下载的是3.4.3版本，在安装前首先需要安装依赖包，在控制台输入： 123sudo apt-get install build-essentialsudo apt-get install cmake git libgtk2.0-dev pkg-config libavcodec-dev libavformat-dev libswscale-devsudo apt-get install python-dev python-numpy libtbb2 libtbb-dev libjpeg-dev libpng-dev libtiff-dev libjasper-dev libdc1394-22-dev\\然后下载OpenCV3.2.0和OpenCV_contrib-3.2.0，下载需要等待一段时间 之后输入： 123456unzip opencv-3.4.3.zip #解压文件cd opencv-3.4.3 #进入文件夹mkdir build #创建编译文件夹cd build #进入camke .. sudo make -j1 -j 是使用多少线程进行编译，在Ubuntu虚拟机上由于我设设置的性能较好，可以使用-j8进行编译，也就是8线程，而在树莓派上则是使用的单线程编译，速度会慢很多，但是保证不会死机，一开始使用-j4时到99%时就死机了。如果-j后不加数字，则默认不限制线程编译 编译完成后输入： 1sudo make install #执行安装 只要过一会就安装完成了。 2、编写Opencv代码 代码如下： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;opencv2/core/core.hpp&gt; #include &lt;opencv2/highgui/highgui.hpp&gt; #include &lt;opencv2/opencv.hpp&gt; using namespace std; using namespace cv; void fun2(Mat); int main() { Mat img = imread(\"orgin.png\");//引入源图片文件 if (img.empty()) { return -1;//若没有图片文件，则为退出 } fun2(img);//将源图片文件传入 fun2() namedWindow(\"orgin\");//新建窗口 imshow(\"orgin\",img);//在orgin窗口下显示img namedWindow(\"new\"); waitKey(0); } void fun2(Mat img) { Mat element = getStructuringElement(MORPH_RECT, Size(15, 15));//图像处理的主要函数，函数的参数第一个为选择的样式，这里我选择的是MORPH_RECT样式，大小设置为15 Mat dstimg; erode(img, dstimg, element);//将源文件进行处理，生成新的图像文件 imshow(\"new\", dstimg); imwrite(\"new.jpg\", dstimg);//将处理后的新图像文件保存为new.jpg } 新建一个文件夹，之后将图像文件和cpp文件放入在同一文件夹内。 3、运行代码 在树莓派上运行Opencv的代码有点繁琐，首先需要安装cmake gui，使用图形界面会比较方便些，这里在终端直接输入： 1sudo apt-get cmake-gui 进行安装。我们开始运行代码。在刚刚的文件夹里新建一个txt文件，这里推荐使用vim，当然也可以使用其他的文本编辑器，取名为CmakeLists.txt。CmakeLists的内容可以到Opencv的安装目录中找到Opencv官方的例子中直接复制过来就可以，不过需要改几个地方。 123456789101112131415161718192021222324252627282930# cmake needs this linecmake_minimum_required(VERSION 2.8)# Define project nameproject(opencv_example_project)# Find OpenCV, you may need to set OpenCV_DIR variable# to the absolute path to the directory containing OpenCVConfig.cmake file# via the command line or GUIfind_package(OpenCV REQUIRED)# If the package has been found, several variables will# be set, you can find the full list with descriptions# in the OpenCVConfig.cmake file.# Print some message showing some of themmessage(STATUS \"OpenCV library status:\")message(STATUS \" version: ${OpenCV_VERSION}\")message(STATUS \" libraries: ${OpenCV_LIBS}\")message(STATUS \" include path: ${OpenCV_INCLUDE_DIRS}\")if(CMAKE_VERSION VERSION_LESS \"2.8.11\") # Add OpenCV headers location to your include paths include_directories(${OpenCV_INCLUDE_DIRS})endif()# Declare the executable target built from your sourcesadd_executable(opencv_example opencvtest.cpp)# Link your application with OpenCV librariestarget_link_libraries(opencv_example ${OpenCV_LIBS}) 首先是为你的Opencv项目取名，当然如果不想改的话官方给的实例里已经给你取好了，其次就是将add_executable中的cpp文件改成自己写的代码的文件名，这样才可以知道编译的是哪个文件。 接下来就是使用cmake-gui编译了。打开终端，输入： 1cmake-gui 打开cmake-gui后看到界面，源代码处我们选择刚刚创建的文件夹，二进制文件一样也选择刚刚创建的文件夹，点击Add Entry，输入Opencv的安装位置，选择build文件夹，如图： 接着分别点击Configure和Generate，显示Configure Done和Generate Done就说明成功了。 回到终端，cd进入刚刚的文件夹，输入： 1ls #查看生成的可执行文件的名称 接着输入： 1./opencv_example 运行。运行结果如下：","link":"/2019/08/21/树莓派-Opencv（一）图像处理/"},{"title":"树莓派+Opencv（二）中文字库","text":"上一次实验完成了Opencv的安装以及图像的简单处理，现在在此基础上完成添加中文字的任务。 一、在字库文件中找到自己的名字 新建一个txt文本文件，写上名字学号，另存为，编码格式选择acsi。如何获得中文的的点阵位置呢，这里我们需要一个强大的工具，UltraEdit。使用UD打开之前创建的txt文件：打开点阵汉字查看程序，打开HZKf2424字库文件，在工具栏选择望远镜图标，也就是搜索图标，搜索E1D4：点击ok后出现的第一个字就是要搜索的字： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;cxcore.h&gt;#include &lt;highgui.h&gt;#include &lt;direct.h&gt;#include&lt;iostream&gt;using namespace std;using namespace cv;const int CC_SIZE = 16;const int SAFE_WIDTH = 10;const int CC_NUMBER = 15;//姓名unsigned char name[7] = \"嵩\";unsigned int name_code[3][2];// 学号unsigned int id_code[12][2] = { { 0xa3, 0xb6 },{ 0xa3, 0xb3 },{ 0xa3, 0xb1 },{ 0xa3, 0xb6 },{ 0xa3, 0xb0 },{ 0xa3, 0xb7 },{ 0xa3, 0xb0 },{ 0xa3, 0xb4 },{ 0xa3, 0xb0 },{ 0xa3, 0xb3 },{ 0xa3, 0xb2 },{ 0xa3, 0xb5 } };unsigned char mat[16][2];FILE* HZK16;IplImage* img;void get_area_position_codes();void get_mat(int a_code, int p_code);void open_file();void draw_one_cc(int num);void release();int main(){ open_file(); get_area_position_codes(); int i, j; for (i = 0; i &lt; 3; ++i) { get_mat(name_code[i][0], name_code[i][1]); draw_one_cc(i); } for (j = 0; j &lt; 12; ++j) { get_mat(id_code[j][0] - 0xa0, id_code[j][1] - 0xa0); draw_one_cc(i + j); } cvShowImage(\"IMAGE\", img); cvWaitKey(0); release(); return 0;}void get_area_position_codes(){ for (int i = 0; i &lt; 3; ++i) for (int j = 0; j &lt; 2; ++j) name_code[i][j] = name[i * 2 + j] - 0xa0;}void get_mat(int a_code, int p_code){ long offset; offset = (94 * (a_code - 1) + (p_code - 1)) * 32L; // 读取数据存入数组 fseek(HZK16, offset, SEEK_SET); fread(mat, 32, 1, HZK16);}void open_file(){ char pbuf[100]; _getcwd(pbuf, 100); strcat(pbuf, \"\\\\HZKf1616.hz\"); // 读取图片 if ((img = cvLoadImage(\"orgin.png\")) == NULL)exit(1); // 打开字体文件 if ((HZK16 = fopen(pbuf, \"rb\")) == NULL)exit(1);}void draw_one_cc(int num){ int width, height; width = img-&gt;width; height = img-&gt;height; int start_x, start_y, size, current_start_x, current_start_y; size = CC_SIZE + SAFE_WIDTH; start_x = width - CC_NUMBER * size; start_y = height - CC_SIZE - SAFE_WIDTH; CvScalar cs; for (int i = 0; i &lt; 16; ++i) for (int j = 0; j &lt; 2; ++j) for (int k = 0; k &lt; 8; k++) if (mat[i][j] &amp; (0x80 &gt;&gt; k)) { cout &lt;&lt; mat[i][j] &lt;&lt; endl; current_start_x = j * 8 + k + start_x + size * num; current_start_y = start_y + i; cs = cvGet2D(img, current_start_y, current_start_x); cs.val[0] = 0;//B cs.val[1] = 69;//G cs.val[2] = 139;//R cvSet2D(img, current_start_y, current_start_x, cs); }}void release(){ cvReleaseImage(&amp;img); fclose(HZK16); img = NULL; HZK16 = NULL;} 该代码只能在windows上成功，在windows上中文的编码格式为utf-8，到了树莓派上，树莓派的中文编码是iso8859-1，所以程序会有错，程序无法运行。window上程序运行效果：树莓派上使用了另一代码，参考如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;#include &lt;iostream&gt;#include &lt;opencv/cxcore.h&gt;#include &lt;opencv2/highgui.hpp&gt;#include &lt;opencv2/opencv.hpp&gt;#include &lt;stdlib.h&gt;using namespace cv;using namespace std;class ShowName{public: ShowName(char *filename); ShowName(char *name, char* code); ~ShowName(); void openfile(); void get_name_code(); void get_mat(unsigned char qh, unsigned char wh); void draw_name(int num); void getasi(char incode[]); void draw_code(int num); void Runtodraw(); void file_Runtodraw();protected: FILE* CONTERNER; FILE* HZK24; FILE* ASI816; unsigned char mat[72]; unsigned char num_mat[16]; char name_code_box[30]; IplImage* img; const int MAPSIZE = 24; const int INTERSIZE = 5; unsigned char name_code[3][2];private: char *Name; char *code; char *Name_code; int sum_word; int current_num;};ShowName::~ShowName() { cvReleaseImage(&amp;img); fclose(HZK24); fclose(ASI816); if (CONTERNER!=NULL) { fclose(CONTERNER); } img = NULL; HZK24 = NULL; ASI816 = NULL; CONTERNER = NULL;}ShowName::ShowName(char *filename) { if ((CONTERNER = fopen(filename, \"rb\")) == NULL)exit(1); fseek(CONTERNER, 0, SEEK_SET); fread(name_code_box, 30, 1, CONTERNER); char *a = name_code_box; Name_code = a; sum_word = strlen(Name_code) - 2; current_num = 0; openfile();}ShowName::ShowName(char *name, char* code) { this-&gt;Name = name; this-&gt;code = code; this-&gt;current_num = 0; this-&gt;sum_word = strlen(Name) / 2 + strlen(this-&gt;code); openfile();}void ShowName::openfile() { char pbuf[100]; getcwd(pbuf, 100); strcat(pbuf, \"/HZKs2424.hz\"); char pbufASC[100]; getcwd(pbufASC, 100); strcat(pbufASC, \"/Asci0816.zf\"); if ((img=cvLoadImage(\"orgin.png\"))==NULL) { exit(1); } if ((HZK24=fopen(pbuf,\"rb\"))==NULL) { exit(1); } if ((ASI816=fopen(pbufASC,\"rb\"))==NULL) { exit(1); }}void ShowName::getasi(char incode[]){ unsigned char gh, wh; unsigned long offset; offset = incode[0] * 16L; fseek(ASI816, offset, SEEK_SET); fread(num_mat, 16, 1, ASI816);}void ShowName::get_mat(unsigned char qh, unsigned char wh) { long offset; offset = (94 * (qh - 1)) + (wh - 1) * 72L; fseek(HZK24, offset, SEEK_SET); fread(mat, 78, 1, HZK24);}void ShowName::draw_code(int num){ int width, height; width = img-&gt;width; height = img-&gt;height; int start_x, start_y, size, current_start_x, current_start_y; size = MAPSIZE; start_x = width - sum_word*size; start_y = height - 16 - INTERSIZE; CvScalar cs; for (int i = 0; i &lt; 16; i++) for (int k = 0; k &lt; 8; k++) if ((num_mat[i]&amp;(0x80&gt;&gt;k))!=NULL) { current_start_x=k+start_x+size*num; current_start_y=start_y+i; cs = cvGet2D(img, current_start_y, current_start_x); cs.val[0] = 0; cs.val[1] = 0; cs.val[2] = 0; cvSet2D(img, current_start_y, current_start_x, cs); }}void ShowName::draw_name(int num) { int width, height; width = img-&gt;width; height = img-&gt;height; int start_x, start_y, size, current_start_x, current_start_y; size = MAPSIZE;// +INTERSIZE; start_x = width - sum_word * size; start_y = height - MAPSIZE - INTERSIZE; CvScalar cs; for (int i = 0; i &lt; 24; ++i) for (int j = 0; j &lt; 3; ++j) for (int k = 0; k &lt; 8; k++) if (((mat[i * 3 + j] &gt;&gt; (7 - k)) &amp; 0x1) != NULL) { // »æµã current_start_x = start_x + i + size * num; current_start_y = start_y + j * 8 + k; cs = cvGet2D(img, current_start_y, current_start_x); cs.val[0] = 0; cs.val[1] = 0; cs.val[2] = 0; cvSet2D(img, current_start_y, current_start_x, cs); }}void ShowName::Runtodraw() { unsigned char mask = 0x80; char tmpcode[3] = { 0 }; while (*Name != NULL) { tmpcode[0] = *Name; tmpcode[1] = *(Name + 1); if (tmpcode[0] &amp; mask) { unsigned char qh, wh; qh = tmpcode[0] - 0xaf; wh = tmpcode[1] - 0xa0; get_mat(qh, wh); draw_name(current_num++); Name += 2; } } while (*code != NULL) { tmpcode[0] = *code; if (tmpcode[0]) { getasi(code); draw_code(current_num++); code++; } } cvShowImage(\"bt\", img); cvWaitKey();}void ShowName::file_Runtodraw() { unsigned char mask = 0x80; char tmpcode[3] = { 0 }; int x = 0; while (*Name_code != NULL) { tmpcode[0] = *Name_code; tmpcode[1] = *(Name_code + 1); if (tmpcode[0] &amp; mask) { unsigned char qh, wh; qh = tmpcode[0] - 0xaf; wh = tmpcode[1] - 0xa0; get_mat(qh, wh); draw_name(current_num++); Name_code += 2; } else if (tmpcode[0]) { getasi(Name_code); draw_code(current_num++); Name_code++; } } cvShowImage(\"bt\", img); cvWaitKey();}int main(){ char *filename = (char*)\"zh.txt\"; ShowName *newname = new ShowName(filename); newname-&gt;file_Runtodraw(); delete newname; return 0;} 这里需要注意几个地方，在Linux无法使用direct.h头文件，_getcwd在Linux下是不需要前面的”_”的，还需要引入unistd.h头文件。 运行方式可以参考我之前的文章：树莓派+Opencv（一）图像处理 程序运行结果：","link":"/2019/08/21/树莓派-Opencv（二）中文字库/"}],"tags":[],"categories":[]}